# MVC Architecture for Unity

The MVC (Model-View-Controller) pattern is an important pattern in software development. It allows for clear structuring of the project and thereby supports the development process. It divides the project into model, view, and controller classes, which fulfill the following general functions:

- **Model**: Classes serve the purpose of maintaining data, both temporarily and statically.
- **View**: Classes determine the behavior and appearance of everything the user sees.
- **Controller**: Classes contain the game logic and are responsible for the communication.

There are several ways to implement the MVC pattern in Unity. In my opinion, the best way to take advantage of this pattern is to have both the organization of the code and the organization of a scene within the Unity editor follow the MVC pattern. Furthermore, it is important that communication between two elements of the project can be ensured without much configuration effort within the Unity editor/inspector. Manually setting references in the Inspector is both time-consuming and prone to errors. Especially across scenes in the case of scene changes or additive scenes, this can quickly lead to confusing solutions. For this reason, I have implemented a version of the MVC pattern that requires minimal configuration effort to allow global access to all views, controllers, and models of the project, regardless of whether the element to be accessed is in the same scene or not. I have oriented myself to the approach of [Eduardo Dias da Costa](https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development), which, however, relies on the manual setting of references in the Inspector, the disadvantages of which I just listed.

## How to Use This Architecture
![Architecture](https://github.com/19Chris98H/MVC_Architecture/assets/63323099/8bde7ff1-c022-4cee-863c-0d1a2899884a)
Here you can see an overview over an example using the architecture. In the following we go step by step through this architecture and everything that is important to know will be mentioned.

Every project requires an "Application" scene, which is always active and loaded first. This scene is already provided in the Scenes folder. All other scenes of the application can then be loaded additively. The "Application" scene thus provides the global area, which is available at all times during runtime. Depending on the project's circumstances, this functionality can be left as it is, or globally used elements, such as a camera in the view, or application settings in the model, can be integrated into this scene. Therefore, this scene already contains game objects for Model, View, and Controller, which contain the template classes. If you decide against adding certain functionalities to this scene, you can remove the three game objects.

Within this scene, no further action is needed in the future, apart from the functionalities you added. For each scene of the Application, which provides some form of content, you can duplicate the "SceneTemplate" and then rename it. This scene now contains the aforementioned three game objects. The classes that have been added as components to the three game objects can also be duplicated and renamed. These three classes are hereinafter referred to as scene-MVC classes and differ from the rest of the Model, View, and Controller classes (hereinafter referred to as MVC classes) in that scene-MVC classes inherit from the generic class SceneArchitectureLayer. The inheritance ensures that when the scene is loaded, the instances of these classes are referenced in the top layer of the MVC hierarchy. All that needs to be done is to create a property according to the added class either in ApplicationModel, -Controller, or -View. It should preferably be limited to one class per scene and per MVC area in order to keep the classes of the top MVC hierarchy layer as clear as possible.

All instances of MVC classes only exist as long as the scene is active. If you have an instance that should exist over the runtime of several existing scenes, an additional scene should be created whose scene-MVC classes hold a reference to this instance and remain active even when the hierarchically considered underlying scenes change. This hierarchical organization of the scenes ensures that there are no MVC class instances in a scene that are needed outside the lifetime of this scene.

MVC classes are manually referenced in the inspector of the scene-MVC classes or nested MVC classes. Manual referencing in the inspector at this level poses no problems, as manual referencing is reduced to adding local elements to the MVC hierarchy and thus no dependencies on other game objects within, or even outside a scene need to be considered. Elements do not need to be manually referenced to each other in any case, and thus there is only one reference in the Inspector for each element, which needs to be adjusted manually in the event of refactoring. All other changes in the course of refactoring take place within the code and are automated in the case of a suitable IDE. To perform the referencing step and thus integrate an MVC class from the 2nd level into the MVC hierarchy, a field as shown in Fig. just needs to be added at the appropriate point.

Every element, whether it is part of the MVC hierarchy or not, can access this hierarchy by inheriting from "GameElement". This abstract class has a reference to the root of the hierarchy and thus every element of the hierarchy can be reached as shown in Fig.

However, when using this architecture, it is important to carefully consider when certain elements are available, i.e., the scene in which they exist is loaded, because only then does a reference to the element exist. At critical points, a null check should therefore be performed. Furthermore, it is recommended to use events, for example when a scene has finished loading, to carry out initializations that require access to the elements of the loaded scene. If you work carefully here, this architecture offers a high degree of flexibility and structured global access.

As a developer, you never stop learning, so I welcome constructive criticism and am always open to suggestions for improvement. Feel free to contact me via [LinkedIn](https://www.linkedin.com/in/christian-h%C3%B6rath-0ba068201/) or by [email](mailto:hoerath.christian@gmail.com).
